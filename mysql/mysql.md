#### 一条查询sql是如何执行的

* 客户端：
* 连接器：管理连接，权限验证
* 查询缓存：map结构，key是sql语句，value是返回结果，只要这个表有更新，则缓存失效。
  * query_cache_type：开启查询缓存，0是关闭，1是开启，2是只有当用户sql语句指定要缓存时才缓存
* 分析器：sql词法分析，语法分析
* 优化器：根据sql语句，执行计划生成，索引选择
* 执行器：操作引擎，返回结果
* 存储引擎：存储数据，提供读写接口



#### 一条更新语句是如何执行的

> Write-Ahead Logging: 先写日志，后写磁盘

* 执行更新sql
* 先查数据是否在内存，不在则读取到内存
* 修改数据
* 将写后的数据加入内存
* 先写redo log （其实先写入buffer，根据设置innodb_flush_log_at_trx_commit的值决定什么时候写入redo log，mysql也有周期性的计划刷新到磁盘）
  * 因为redo log（ib_logfile0，ib_logfile1），innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。
  * InnoDB 的 redo log 是固定大小的，类似环状列表，当redo快满或者写满时，会将部分数据刷到
* 处于prepare状态
* 写binlog （其实也是先写入cache,然后在根据sync_binlog的参数fsync到磁盘或者mysql周期性计划刷新到磁盘）
* 提交事务，处于commit状态



#### 索引：（是为了加快数据查询的一种数据结构）

* MyISAM ：B树 （索引文件跟数据不分开，所有的节点都包含数据）
* Innodb：B+树 （索引文件与数据文件分开，只有子节点包含数据）
* Memory：hash索引，内存

* 覆盖索引：也就是索引已经包含返回的数据，即可以不用再去查询主键索引。
* 主键索引（聚集索引）：主键的索引结构，包含全部数据，其他非聚集索引只包含索引所在的列的值以及主键值
* 多列索引（复合索引）：得支持最左前缀原则
* 回表：是指根据非聚集索引由于包含的数据量少，不足于返回查询数据时，需要根据主键的值去访问主键索引然后查询数据返回结果。
* 索引下推：为了减少回表的次数，会对索引中包含的字段先做判断，直接过滤掉不符合的记录。5.6版本支持，之前都是要回表，然后判断不符合才过滤。



#### 数据页

* mysql默认数据页大小为16K，存储以及读取都是按照数据页大小存储或者读取。
* 假设索引中固定数据页，如果删除了数据，mysql的表的大小并不会小，因为并没有删掉数据，只是将数据进行标记，之后可以插入此位置的数据或者相邻位置直接复用，所以会出现页空洞，需要执行alter table t engine innodb；或者是重建索引。



#### 唯一索引以及普通索引的区别：

* 查询是一样的，不同在于更新。

* 修改：change buffer
  * 唯一索引：键必须唯一，在修改操作时，会去读取数据到内存，因为要判断键是不是唯一，然后修改内存
  * 普通索引：如果不影响数据一致性，直接将更新加入到change buffer（buffer pool的缓存，change buffer最大能用50%），只有当读取这个数据页，需要将数据加入到内存时，才会merge 合并change buffer以及读取到的数据，change buffer即会在内存中也会在磁盘中。

  

#### mysql为啥不走索引

* 隐式的类型替换
* 使用函数
* 字符集编码转化





























