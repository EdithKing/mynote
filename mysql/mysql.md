#### 一条查询sql是如何执行的

* 客户端：
* 连接器：管理连接，权限验证
* 查询缓存：map结构，key是sql语句，value是返回结果，只要这个表有更新，则缓存失效。
  * query_cache_type：开启查询缓存，0是关闭，1是开启，2是只有当用户sql语句指定要缓存时才缓存
* 分析器：sql词法分析，语法分析
* 优化器：根据sql语句，执行计划生成，索引选择
* 执行器：操作引擎，返回结果
* 存储引擎：存储数据，提供读写接口



#### 一条更新语句是如何执行的

> Write-Ahead Logging: 先写日志，后写磁盘

* 执行更新sql
* 先查数据是否在内存，不在则读取到内存
* 修改数据
* 将写后的数据加入内存
* 先写redo log （其实先写入buffer，根据设置innodb_flush_log_at_trx_commit的值决定什么时候写入redo log，mysql也有周期性的计划刷新到磁盘）
  * 因为redo log（ib_logfile0，ib_logfile1），innodb就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。
  * InnoDB 的 redo log 是固定大小的，类似环状列表，当redo快满或者写满时，会将部分数据刷到
* 处于prepare状态
* 写binlog （其实也是先写入cache,然后在根据sync_binlog的参数fsync到磁盘或者mysql周期性计划刷新到磁盘）
* 提交事务，处于commit状态



#### 索引：（是为了加快数据查询的一种数据结构）

* MyISAM ：B树 （索引文件跟数据不分开，所有的节点都包含数据）

* Innodb：B+树 （索引文件与数据文件分开，只有子节点包含数据）

* Memory：hash索引，内存

* 覆盖索引：也就是索引已经包含返回的数据，即可以不用再去查询主键索引。

* 主键索引（聚集索引）：主键的索引结构，包含全部数据，其他非聚集索引只包含索引所在的列的值以及主键值

* 多列索引（复合索引）：得支持最左前缀原则

* 回表：是指根据非聚集索引由于包含的数据量少，不足于返回查询数据时，需要根据主键的值去访问主键索引然后查询数据返回结果。

* 索引下推：为了减少回表的次数，会对索引中包含的字段先做判断，直接过滤掉不符合的记录。5.6版本支持，之前都是要回表，然后判断不符合才过滤。

* 优化器选择索引的条件：

  >  采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。而数据表是会持续更新的，索引统计信息也不会固定不变。所以，当变更的数据行数超过 1/M 的时候，会自动触发重新做一次索引统计。

  * 如果innodb_stats_persistent设置为on的情况下，表示统计信息会持久化存储，那么N=20，M=10
  * 如果 innodb_stats_persistent设置为off的情况下，表示统计信息会保存到内存中，那么N=8，M=16
  * 如果mysql走的索引不对，可以重做一次索引统计看看，analyze table 表名。

* 如何给字符串加索引：

  * 字符串搜索符合最左前缀原则，如果将根据字段全部建索引，如果字段长，那么索引一页存的数据就少了，如果只创建前几个字符做索引，那么会导致无法做覆盖索引，会增加回表的速度。

* order by 如果是在索引树上进行order by那么就不用考虑排序会生成临时表的问题，排序过程中如果字段值大于规定的字段值，则采用rowid 算法排序，否则则用全字段排序，排序内存不够时，则会生成文件。



#### 数据页

* mysql默认数据页大小为16K，存储以及读取都是按照数据页大小存储或者读取。
* 假设索引中固定数据页，如果删除了数据，mysql的表的大小并不会小，因为并没有删掉数据，只是将数据进行标记，之后可以插入此位置的数据或者相邻位置直接复用，所以会出现页空洞，需要执行alter table t engine innodb；或者是重建索引。



#### 唯一索引以及普通索引的区别：

* 查询是一样的，不同在于更新。

* 修改：change buffer
  * 唯一索引：键必须唯一，在修改操作时，会去读取数据到内存，因为要判断键是不是唯一，然后修改内存
  * 普通索引：如果不影响数据一致性，直接将更新加入到change buffer（buffer pool的缓存，change buffer最大能用50%），只有当读取这个数据页，需要将数据加入到内存时，才会merge 合并change buffer以及读取到的数据，change buffer即会在内存中也会在磁盘中。

  

#### mysql为啥不走索引

* 隐式的类型替换
* 使用函数
* 字符集编码转化



#### DDL： 

​	如何修改表结构：新建临时表，将临时表结构修改，然后将数据全部导入到新表，然后替换原表。

​	5.6之后在线修改ddl：新建临时表，将临时表结构修改，然后将数据全部导入到新表，此时修改的表都将写入一个日志文件（row log），待原表数据导完，将row log的数据写入，然后替换原表。

5.6之前，没有在线修改的，修改表结构会将表锁住，阻塞sql。首先是metadata lock（元数据锁）加表上，读会加元数据读锁，改加元数据写锁，写锁会阻塞对原表的读取。5.6之后虽然修改表结构，但是也会加元数据写锁，之后会退化成读锁，避免其他修改表结构。



#### 统计表结果数据

* myisam由于是不支持事务，所以他将数据行数都统计在一个表里，count(*)直接返回这个数据。
* innodb由于是mvcc，所以不会跟myisam的数据行数统计在表里，只能查询。
* 由于count字段值等会先将字段进行判断，判断字段值是不是为null，不为null则统计，所以会有判断的过程
  * count(字段值）< count（主键）< count（1）~ count（*）



#### 查一行慢

* 有进程对表进行锁表或者行锁
* 后台在flush数据到磁盘



#### 事务四大特性

* 原子性：是指事务是一个不可分割的工作单位，事务的操作要么全部成功，要么全部失败。
* 一致性：事务前后数据的完整性必须保持一致。
* 隔离性：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
* 持久性：持久性是指一个事务一旦被提交，它岁数据库中数据的改变就是永久性的。



mysql的4种事务：

* 读未提交
* 读已提交
* 可重复读
* 序列化



脏读：读到另外一个事务未提交的数据。

不可重复读：是指事务前后，事务多了一些update和delete数据。

幻读：是由于事务过程中，前后查询，返回的数据的行数多了。主要是insert



















