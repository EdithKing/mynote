### 如何认为那些对象可回收

* 引用计数法:

  >  在对象中添加一个计数器，每当有一个地方引用时，计数器加一，每失效一个引用时，计数器减一，为0时则标记可回收。（实现简单，无法回收循环引用的情况）。

* 可达性分析：

  > 通过一系列的GC Roots的根对象作为起始节点集，从这些节点开始，根据应用关系向下搜索，搜索过程的路径就是引用链，如果某个对象跟所有GC Roots间没有任何引用链相连，则证明这个对象不可达，此对象是不可能在被使用的。

  * GC Roots的对象
    * 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
      参数、局部变量、临时变量等。
    * 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
    * 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
    * 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
    * Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
    * 所有被同步锁（synchronized关键字）持有的对象。
    * 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
    * 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不
      同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合

#### 引用

* 强引用：

  > 是指在程序代码之中普遍存在的引用赋值，即时发生OOM，也不会回收

* 软引用：

  >  是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内
  > 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，
  > 才会抛出内存溢出异常。

* 弱引用：

  >  弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只
  > 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只
  > 被弱引用关联的对象。

* 虚引用(也称为“幽灵引用”或者“幻影引用”)：

  > 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

PS：即时被可达性分析算法标记对象不可达，对象也不一定会回收，仅仅是第一层标记，还需要进行筛选，筛选方式看对象是否有必要执行finalize（）。假设对象类没覆盖finalize方法或者是finalize方法已经执行过，则认为没必要执行。

> 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的
> 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()
> 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。
> 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导
> 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对
> 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对
> 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己
> （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集
> 合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。



#### 方法区回收

* 常量回收:
* 类回收：
  * 该类所有的实例都已经被回收
  * 加载该类的类加载器已经被回收
  * 该类的Class对象没有在任何对方被引用

PS: 使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息





















