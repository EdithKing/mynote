### 如何认为那些对象可回收

* 引用计数法:

  >  在对象中添加一个计数器，每当有一个地方引用时，计数器加一，每失效一个引用时，计数器减一，为0时则标记可回收。（实现简单，无法回收循环引用的情况）。

* 可达性分析：

  > 通过一系列的GC Roots的根对象作为起始节点集，从这些节点开始，根据应用关系向下搜索，搜索过程的路径就是引用链，如果某个对象跟所有GC Roots间没有任何引用链相连，则证明这个对象不可达，此对象是不可能在被使用的。

  * GC Roots的对象
    * 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
      参数、局部变量、临时变量等。
    * 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
    * 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
    * 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
    * Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
    * 所有被同步锁（synchronized关键字）持有的对象。
    * 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。
    * 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不
      同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合

#### 引用

* 强引用：

  > 是指在程序代码之中普遍存在的引用赋值，即时发生OOM，也不会回收

* 软引用：

  >  是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内
  > 存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，
  > 才会抛出内存溢出异常。

* 弱引用：

  >  弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只
  > 能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只
  > 被弱引用关联的对象。

* 虚引用(也称为“幽灵引用”或者“幻影引用”)：

  > 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。

PS：即时被可达性分析算法标记对象不可达，对象也不一定会回收，仅仅是第一层标记，还需要进行筛选，筛选方式看对象是否有必要执行finalize（）。假设对象类没覆盖finalize方法或者是finalize方法已经执行过，则认为没必要执行。

> 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的
> 队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()
> 方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。
> 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导
> 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对
> 象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对
> 象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己
> （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集
> 合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。



#### 方法区回收

* 常量回收:
* 类回收：
  * 该类所有的实例都已经被回收
  * 加载该类的类加载器已经被回收
  * 该类的Class对象没有在任何对方被引用

PS: 使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息



#### 垃圾收集算法

* 分代收集理念：
  * 弱分代假说：绝大部分对象都是朝生夕死。
  * 强分代假说：熬过越多次垃圾收集过程的对象就越难于消灭。
  * 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。（存在互相引用的两个对象，是应该倾向于同时生存和同时消亡的）。
* 垃圾回收算法
  * 标记清除算法：
  * 标志复制算法:
  * 标记整理算法：



### 垃圾收集停顿点

* 根节点枚举：所有的收集器在根节点枚举这一步骤时都是必须暂停用户线程的。所以会暂停用户线程，势必就会对正在进行的线程会进行中断，中断方式有抢先式中断，主动式主动。

  * 抢先式中断：直接中断用户线程，当判断用户线程不在安全点时，重新执行此用户线程，让其到达安全点。
  * 主动式中断：当垃圾收集器需要中断线程时，不直接操作，而且设定一个标志位，各个线程执行过程时会不停地主动去轮询这个标志。一旦发现标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够的内存分配新对象。
  * 安全点：用户线程可暂停的可中断的代码点。
  * 安全区域：安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化。当用户线程进入安全区域时，会标识自己已经在安全区域，垃圾收集器并不需要管这些已经在安全区域的线程，当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集器其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行，否则它就必须一直等待，直到收到可以离开安全区域的信号为止。

*  记忆集和卡表

  * 记忆集：为了解决对象跨代引用所带来的问题（少量跨代引用去扫描整个老年代），垃圾收集器在新生代中建立了名为记忆集的数据结构，用以避免把整个老年代加入GC Roots扫描范围。
  * 卡表：字节数组卡表的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页，一般来说，卡页大小都是以2的N次幂的字节数，通过下面代码可以HotSpot使用的卡页是2的9次幂，512字节。一个卡页的内存中通常包含不止一个对象，只要卡页内有一个或更多的对象的字段存在着跨代指针，那么将对应卡表的数组元素标识为1，称为这个元素变脏，没有则为0，垃圾收集发生时，只要针对这些变脏的元素，将他们加入GC Roots即可。
  * 如何维护卡表：引用写屏障，会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销。

  ```java
  CARD_TABLE [this address >> 9] = 0;
  ```



* 并发的可达性分析

  * 增量更新
  * 原始快照

  

#### 垃圾收集器

* Serial：单线程垃圾收集器
* Serial Old: Serial的老年代版本

* ParNew:多线程版本的Serial
* Parallel Scavenge：吞吐量优先的垃圾收集器
* Parallel Old：老年代的Parallel Scavenge
* CMS(ConcMarkSweep)：标记清除算法，用以老年代
  * 初始标记：暂停用户线程，标记一下GC Roots能直接关联的对象。
  * 并发标记：并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
  * 重新标记：则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的
    标记记录。需要暂停用户线程。
  * 并发清除：理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。（会产生浮动垃圾）
* G1（Garbage First）



































