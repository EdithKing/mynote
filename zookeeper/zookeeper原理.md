# zookeeper原理

> zookeeper是一个分布式协调的服务，设计目标是将那些复杂且容易出错的服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供用户使用。能运用在数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，master选举，分布式锁和分布式队列等。


一致性协议：
* 2PC：两阶段提交
	+ 投票阶段
		1. 事务询问：协调者向所有的参与者发送内容，询问是否可以执行事务提交操作，并等待各参与者响应
		2. 执行事务：参与者执行事务操作，并写入redo和undo写入日志信息
		3. 反馈信息：能成功提交就yes，不能就no
	+ 提交阶段（假设全部参与者返回都是Yes）
		1. 发送提交请求：协调者向所有的参与者发送提交事务
		2. 参与者提交事务：正式提交事务，释放资源
		3. 反馈信息：提交后发送ACK事件
		4. 事务完成：收到所有参与者的ACK事件后，事务完成

	优点：
	* 原理简单，使用方便，像mysql就采用这种二阶段提交的事务

	缺点：
	* 过于保守：如果一台机器返回NO，就不提交了，mysql也一样，有一个操作报错则全部回滚
	* 同步阻塞：在事务执行过程中，全部逻辑都处于阻塞状态
	* 单点问题：协调者就一个，假设宕机，那么所有的参与者将无法运转

* 3PC：三阶段提交
	+ 投票阶段
		1. 事务询问：
		2. 反馈信息
	+ 执行事务预提交
		1. 发送事务预提交请求
		2. 事务预提交
		3. 各参与者反馈信息（假设有一个为no，则发送事务中断请求）
	+ 提交阶段（全部为yes）
		1. 发送提交请求
		2. 参与者执行事务提交
		3. 参与者反馈信息
		4. 完成事务
		
	优点：
	* 相比二阶段提交，降低了阻塞范围，也能在单点故障后使数据保持一致

	缺点：
	* 如果在执行事务预提交阶段出现网络分区，那么数据将不一致，就是相当于有部分参与者并没有参与进来，而参与进去的都反馈yes，那么将事务提交后，就会出现数据不一致。


* paxos协议
	* 

zookeeper集群的三种角色：
* leader：领导者，负责进行投票的发起和决议，更新系统状态
* follower：追随者，用于接收客户端请求并在选主过程参与投票
* ovserver：观察者，不参与投票，也不参与选主，只同步leader状态


zookeeper实现原理：
	ZAB协议：zab协议是为分布式协调服务zookeeper专门设计的一种支持崩溃回复的原子广播协议
	协议包含两种模式，崩溃恢复，消息广播
* 崩溃恢复
	当leader崩溃退出与重启等异常情况或者是网络故障时，ZAB协议就会进行恢复状态，并选举产生一个新的Leader服务器，当选举产生了新的leader服务器，同时集群中的超过半数的机器已经进行状态同步之后，zab协议就会退出恢复模式
* 消息广播
	类似于二阶段提交过程，针对客户端请求，leader服务器会生成对应的事务proposal，并将其发送给集群中其余所有的机器，然后在分别收集各自的投票，最后根据投票结果进行事务是否提交。这里是简化了2PC提交的过程，并没有等待全部的参与者反馈，而是超过集群半数的参与者同意，那么事务就提交，也包括最终完成事务也是仅仅确定半数就好，这样是不是就会在leader单点故障的情况下出现数据不一致的情况，并不会，因为zab协议还通过了崩溃恢复模式，将集群数据保持一致。

	leader服务器会分配一个全局单调递增的ID给proposal，这个为事务ID（zxid），要保证消息严格的因果关系，因此必须将每一个事务（proposal）按照其zxid的先后顺序来进行排序与处理。
	leader服务器会为每一个follower服务器都分配一个单独的队列，将事务proposal依次放入队列中，队列特点就是先进先出，所以消息也是按照入队列的顺序发出的，follower服务器接收到这个proposal，先将其以事务日志形式保存进本地磁盘，并成功写入后反馈给leader服务器一个ack响应，当leader收到超过半数的follower的ack响应就会发送提交请求，然后follower搜到提交消息后，也会完成对事务的提交。

	
崩溃恢复：
	当leader故障后，因为要确保提交已经被leader提交的事务，也要丢弃那么被跳过的事务。而且因为zxid是唯一的，还是单调递增的，所以被选举出来的leader肯定是剩下集群中事务id最大的一个。集群中机器状态为looking，停止接受外部请求，有follower（认为自己有能力成为leader）会发送选主请求，其余follower将发送自己最大事务id发送给整个集群，然后每一个follower会对别人发送的事务id进行比较，如果自己大，那么依旧是投票给自己，如果收到别人的比较大，那么下一轮将票投给那个事务id最大的一个，如果一样，那么还会比较myid，myid大的作为leader，那么拟leader，也就是发起投票的那个服务器将接受投票结果，将票为半数以上的服务器选为leader，然后就更改服务器状态，leader状态为LEADING，follower机器的状态为FOLLOWING，然后每一个follower将自己最大的zxid发送给leader，然后开始同步数据。follower只会接受比自己大的提议，小的则忽略，数据同步完成后，zab协议会退出崩溃恢复状态。没同步数据的zk并不会加入可用列表中。

zxid的组成：
	zxid是一个64位数字，高32位为leader的周期，低32为事务递增
	低32位是发起事务都会加1，而高32位只有当更换leader之后，才+1，然后低32位重置为0









